# 数据结构第一次大作业 图像处理部分开源
### 前言
原计划在昨天生日的时候开源，然而bug还没改完，故推迟到今天发<br>
由于该作业不强制要求图像处理，主要考察后续的路径规划算法，故将本代码开源，希望能为大家提供思路，减轻同学们的工作量<br>
10.16更新:已上传全部代码，但仍然存在不少bug，受时间限制无法达到完美<br>

### 代码说明
本代码作用为：<br>
输入一张电子地图的截图，识别道路和交叉点，输出道路的端点序号及道路长度<br>
然后将道路端点序号和长度输入矩阵，用弗洛伊德算法求解最短路径<br>
然后输出最短路径经过的路口序号，并在原始图片上叠加显示路径<br>
注:<br>
map_identify.h 主要为图像处理部分头文件<br>
find_shortest_path.h 主要为弗洛伊德算法求最短路径的头文件<br>
get_road_img.cpp 是对图像的预处理，提取出道路部分<br>
rosenfeld.cpp 是对图像进行细化处理，使用rosenfeld算法<br>
cross_point_identify.cpp 是对细化后的图像提取交叉点，图像处理核心算法<br>
road.cpp 是获取各道路长度和端点序号，主要依靠opencv自带的一些函数进行操作<br>
find_shortest_path.cpp 对应find_shortest_path.h ，主要为执行弗洛伊德算法，包括创建地图、初始化地图、用弗洛伊德算法生成矩阵、输出和绘制等<br>
main.cpp 为主函数<br>

注意：<br>
本代码需要使用opencv库，输入图像方面推荐截取学校官网的华工电子地图(其他地图可能有文字遮挡，且需要改动参数)<br>

### 代码思路
由于华工官网电子地图的道路并非纯白色，故先用photoshop吸管工具拾取道路RGB数值，提取特定RGB值的区域(道路)<br>
随后使用细化算法提取道路骨架，opencv contrib中有给出细化算法，本代码使用的是rosenfeld细化算法<br>
之后的步骤是提取交叉点和道路，具体思路见代码(自认为还算巧妙，但时间复杂度较高，还有大幅优化的空间)<br>
最后的排序和输出虽然不算复杂，但debug花了我好长的时间<br>
之后就是建立地图并用得到的端点和道路长度来初始化地图,然后采用弗洛伊德算法，生成两个矩阵，分别指示距离和路线<br>
最后输出相关信息，结束程序<br>


### 存在问题
1.每次运行结果可能存在差异，即道路左右端点代号可能会改变，经测试是由端点提取算法导致，暂时没有解决，加入最近点寻找机制后应该可以规避该问题<br>
2.输出的道路可能无法完全显示，即有中断的道路,暂时不清楚原因<br>
3.运行一段时间后可能出现无响应情况，在更换地图后较为常见，无法稳定复现，暂时不清楚原因<br>


### 使用方法
ubuntu : <br>
(在项目文件夹下) <br>
```
mkdir build
cd build
cmake ..
make
cd ../bin
./main
```
windows :<br>
使用cmake_gui生成vs项目文件，在vs中编译项目

### 其他
写这份代码真的花了不少时间，比实习任务还耗时就离谱(小小吐槽一下)<br>
由于此代码只是图像处理部分，且写得比较赶，封装程度不高，也可能存在一些bug，希望大家见谅<br>
后续有空的话,可能会持续更新,可以留意一下<br>
最后祝大家国庆节快乐！
